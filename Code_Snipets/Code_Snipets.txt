
Consider below code:
public class Test {
public static void main(String[] args) {
char c = 'Z';
long I = 100_001;//from JDK1.7 for a literal we can give_ also, if we give compiler will remove that in.class file
int i = 9_2;//from JDK1.7 for a literal we can give_also, if we give compiler will remove that in.class file
float f = 2.02f;
double d = 10_0.35d;//from JDK1.7 for a literal we can give_ also, if we give compiler will remove that_in.class file
I = c + i;//char + int = int int -----> long (implicit)
f=c*1*i* f;//char * long*int*float = float
f=1+i+c;//long+int+char = long long---> float(implicit)
i = (int)d;//double----> int(explicit)
f = (long)d;//double---> long, long ---> float (implicit)
}
}
Does above code compile successfully?
A. Yes
B. No I
Answer: A



---------------------------


class Test
{
public static void main(String[] args)
{
int a = 20; // a = 18
int var= --a * a+++ a-----a;// var = 19 * 19 +20-18 = 363
System.out.println("a = " + a);// a = 18
System.out.println("var = " + var);//var= 363
}
}
A.
a = 18
var=363
B.
a = 363
var=363
C. Compilation Error
D.
a = 25
var= 363
answer: A



---------------------------


class Test
{
public static void main(String[] args)
{
int i = 5; // i = 5,6,7
//5 < 6(true)
if (i++ < 6)
{
System.out.println(i++);//System.out.println(6)
}
}
}
A. 5
B. 6
C. Program executes succesfully but nothing is printed on to console
D. 7
answer: B(6)


---------------------------


int x = 4;//line-n1
int y = 4++;//line-n2 whether it is post or pre-increment it can only be done on variables not on direct literals 
System.out.println(x);
System.out.println(y);

A. line-n1 CompileTimeError

B. x=4
y=5

C. x=5
y=5

D. line-n2 CompileTimeError

Answer: D

-------------------------

int x = 4;//line-n1
int y =++(++x);//line-n2 whether it is post or pre-increment it can only be done on variables not on direct literals
System.out.println(x);
System.out.println(y);
A. line-n1 CompileTimeError
B. x=4
y=5
C. x=5
y=5
D. line-n2 CompileTimeError I
Answer: D

-----------------------------


boolean b=true;//line -n 1
b++;//line-n2 Ans. increment and decrement is applicable only for integral, floating type and character type not for boolean type
System.out.println(b);
A. line-n1 Compile Time Error
B. line-n2 Compile Time Error
C. false
D. true
E. None of the above
Anser: B



----------------------------


int b,c,d;//declaring the variables 
int a = b = c =d=10;
Will the code compile?
A. yes
B. no
Answer: A


----------------------------



int a = b = c = d = 20;//b,c,d not declared but using so CompileTime Error 
System.out.println(a);
Will the code compile?
A. yes
B. no
Answer: B

----------------------------


byte c = (10> 20) ? 30: 40;//literals are involved so compiler performs operation byte c =40;
byte d =(10<20) ? 30: 40;//literals are involved so compiler performs operation byte d =30;
System.out.println(c);//40
System.out.println(d);//30
A. 30
   40

B. 40
   30

C. 10
   20

D. 20
   10

E. CompileTime error

Answer : B

---------------------

int a = 10, b = 20;//type checking is valid no problem
byte c = (a>b)? 30: 40;//literals are not involved in operation, so compiler would just check type checking of result

Compiler will see 30,40 type it knows is int, so the result should be of int type only. if compiler only perform the 
operation it will try to map with casting chart otherwise it wants the exact type.


byte d =(a<b) ?30: 40;
System.out.println(c);
System.out.println(d);
A. 30 40
B. 40 30
C. 10 20
D. 20 10
E. CompiletimeError
Answer: E



--------------------------


Consider below statements:
int x = 5____0;// Literal values can be with _ also but it should be in b/w not at the beggining or at the end
int y = ___50;//invalid becoz starts with _
int z = 50_____;//invalid becoz in ends with _
float f = 123.76_86f;//valid
double d = 1_2_3_4;//valid
How many statements are legal?
A. One statement only
B. Two statement only
C. Three statement only
D. Four statement only
E. All 5 statement only.
Answer : C



--------------------------------


int x=10, y=15;
if(++x < 10 & ++y > 15) { //11<10(false) | 16>15(true) Γ x++;
}
else { y++;
} System.out.println(x+"----"+y);

predict x and y value by replacting the operators with || => x and y value ?
|| -> it is called as "Short circuit OR operator"
second operand evaluation will happen only if the first operand result is false
x = 12
y = 16
&& => x and y value
&& -> it is called as "Short circuit AND operator" I
second operand evaluation will happen only if the first operaand result is true
x = 11
y = 16
| => x and y value
|=> It is called as "Logical OR operator" both the operands result will be evaluated.
x = 12
y = 16
& => x and y value ?
& -> It is called as "Logical AND operator" both the operands result will be evaulated
x =11
y =17


-----------------------------


int x=10;
if(++x < 10 && ((x/0)>10)) { //11<10===> if(false) System.out.println("Hello");
}
else {
System.out.println("Hi");
}
A. Hello
B. Hi
C. Compile Time Error
D. Exception
E. None of the above.

Answer: B




------------------------------------




int i=10;//10
int j=20;//30
int k= (j+=i)/5;// k = (j= j+i)/5
k= (j=20+10)/5
k = (j=30)/5
k= 30/5
k= 6
System.out.println(i+":"+j+":"+k);
A.10:30:6
B.10:22:22
C.10:22:20
D.10:22:6 I
Answer : A







int x =10;
if(x){//CE: unexpected type required: boolean, found:int System.out.println("hello");
}else{
System.out.println("hiee");
}
A. hello
B. hiee
C. CompileTime Error
D. Some problem by jvm at the execution
E. None of the above
Answer: C

-----------------

int x =10;
if(x=20){
System.out.println("hello");
}else{
System.out.println("hiee");
}
A. hello
B. hiee
C. CompileTime Error
D. Some problem by jvm at the execution
E. None of the above 1
Answer: C




int x =10;
if(x==20){//operator used is Equality operator ==,!= output is boolean

System.out.println("hello"); 
}else{
System.out.println("hiee");
}
A. hello
B. hiee
C. CompileTime Error
D. Some problem by jvm at the execution
E. None of the above I
Anser: B

--------------------------


boolean b= false;
if(b=true){//assignment operator is evaluted on boolean type, JVM if(true) System.out.println("hello");
}else{
System.out.println("hiee");
}
A. hello
B. hiee
C. CompileTime Error
D. Some problem by jvm at the execution
E. None of the above
Answer: A


-----------------------

boolean b= false;
if(b==true){//Equality operator result is boolean type, JVM if(false == true) ----> if(fals System.out.println("hello");
}else{
System.out.println("hiee");
}
A. hello
B. hiee
C. CompileTime Error
D. Some problem by jvm at the execution
E. None of the above
Answer: B


------------------------


if(boolean)
stmt-1;
Note: if there is only statement which needs to be a part of if, then {} is optional.
if(true)
System.out.println("hello");
A. Compile Time Error
B. hello
C. Some problem by jvm at the execution
D. None of the above 
Answer: B


-----------------


public class Test{
public static void main(String args[]){
if(true);
}
}
A. Compile Time Error
B. hello
C. Some problem by jvm at the execution
D. No Output
Answer: D(becoz; is also valid java statement)


--------------------------

Note: if there is only statement which needs to be a part of if, then {} is optional, but that statement should not be a declarative statement.
public class Test{
public static void main(String args[]){
if(true)
int x=10; //CE: declaration not allowed here
}
}
A. Compile Time Error
B. hello
C. Some problem by jvm at the execution
D. No Output
Answer: A


-----------------------------

public class Test{
public static void main(String args[]){
if(true) {
int x=10; //valid for compiler becoz of {}
}
}
}
A. Compile Time Error
B. hello
C. Some problem by jvm at the execution
D. No OutputI
Answer: D



-------------------


public class Test{
public static void main(String args[]){
if(true)
System.out.println("hello");//Dependent of if statement
System.out.println("hiee");//Independent of if statement
}
}
How many statements are independent of if?
A. 0-stmt
B. 1-stmt
C. 2-stmt
D. 3-stmt
Answer: B



---------------------


public class Test{
public static void main(String args[]){
int x=10;
switch(x)
{
System.out.println("hello"); //Statement is not a part of case lable so CompileTime Error
}
}
}
A. CompileTimeError
B. hello
C. JVM will create problem at the runtime
D. None of the above
answer: A

--------------------------------- 



public class Test{
public static void main(String args[]){
int x= 10;
int y = 20;
switch(x)
{
case 10: System.out.println("hello");
break;
case y:System.out.println("hiee"); //CE: 'y' value is not CompileTime Constant
break;
}
}
}
A. CompileTimeError
B. hello
C. hiee
D. JVM will create problem at the runtime
E. None of the above

Answer : A.CompileTimeError


----------------------------
public class Test{
Nitin Manjan
public static void main(String args[]){
int x= 10;
final int y = 20;//final means compiler will get to know the value and compiler treats it as "CompileTime Constant".
switch(x)
{
case 10: System.out.println("hello");
break;
case y:System.out.println("hiee");
break;
1}
}
A. CompileTimeError
B. hello
C. hiee
D. JVM will create problem at the runtime
E. None of the above
Answer: B	


----------------------

public class Test{
public static void main(String args[]){
int x=10;
switch(x+1)
{
case 10:
case 10+20:
case 10+20+30:
}
}
}
A. CompileTimeError
B. No Output
C. JVM will create problem at the runtime
D. None of the above
Answer: B


-------------------


public class Test{
public static void main(String args[]){
byte x=10;
switch(x)
{
case 10:System.out.println("hello");
break;
case 100: System.out.println("hiee");
break;
case 1000: System.out.println("byee");//CE: possibly loss of precession from byte to int
break;
}
}
}
A. CompileTimeError
B. hello
C. JVM will create problem at the runtime
D. hiee

Answer : A.CompuleTimeError


---------------------------------


public class Test{
public static void main(String args[]){
byte x=10;
switch(x+1) //byte + int int -- { , so switch(int)
case 10:System.out.println("hello"); break;
case 100: System.out.println("hiee"); break;
case 1000: System.out.println("byee");
break;
}
}
}
A. CompileTimeError
B. hello
C. JVM will create problem at the runtime
D. hiee
E. byee
F. no output

Answer: no output



----------------------------



public class Test{
public static void main(String args[]){
int x=97;
switch(x){
case 97:System.out.println("97");
break;
case 99:System.out.println("99");
break;
case 'a':System.out.println("100"); // int x= 'a'; x = 97
break;
}
}
}
A. 97
B. CompileTimeError
C. JVM will create problem at the runtime
D. 99
E. 100 I
Answer: B



------------------



public class Test {
public static void main(String[] args) {
int a = 5;
int x = 10;
switch(x) {
case 10:
a *= 2;// a = a*2 = 5*2 = 10, a = 10
case 20:
a *= 3;//a = a*3, a=10*3 = 30, a = 30
case 30:
a *= 4;// a = a*4, a =30 * 4 =120, a= 120
}
System.out.println(a);//120
}
}
A. 5
Β. 10
C. 30
D. 120
E.CompileTimeError

Answer : D.120